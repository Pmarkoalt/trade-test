"""Signal tracker for recording generated signals."""

import logging
from datetime import datetime
from typing import List, Optional

from trading_system.tracking.models import (
    ConvictionLevel,
    SignalDirection,
    SignalStatus,
    TrackedSignal,
)
from trading_system.tracking.storage.base_store import BaseTrackingStore

logger = logging.getLogger(__name__)


class SignalTracker:
    """
    Track all signals generated by the system.

    This class is the main interface for recording signals
    and should be called from the signal generation pipeline.

    Example:
        tracker = SignalTracker(store)

        # When generating signals
        for recommendation in recommendations:
            signal_id = tracker.record_signal(recommendation)

        # When delivering signals
        tracker.mark_delivered(signal_id, method="email")
    """

    def __init__(self, store: BaseTrackingStore):
        """
        Initialize signal tracker.

        Args:
            store: Storage backend for persisting signals.
        """
        self.store = store

    def record_signal(
        self,
        symbol: str,
        asset_class: str,
        direction: SignalDirection,
        signal_type: str,
        conviction: ConvictionLevel,
        signal_price: float,
        entry_price: float,
        target_price: float,
        stop_price: float,
        technical_score: float = 0.0,
        news_score: Optional[float] = None,
        combined_score: float = 0.0,
        position_size_pct: float = 0.0,
        reasoning: str = "",
        news_headlines: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
    ) -> str:
        """
        Record a newly generated signal.

        Args:
            symbol: Ticker symbol (e.g., "AAPL", "BTC").
            asset_class: "equity" or "crypto".
            direction: BUY or SELL.
            signal_type: Type of signal (e.g., "breakout_20d").
            conviction: HIGH, MEDIUM, or LOW.
            signal_price: Price when signal was generated.
            entry_price: Recommended entry price.
            target_price: Target price for exit.
            stop_price: Stop loss price.
            technical_score: Technical analysis score (0-10).
            news_score: News sentiment score (0-10), if available.
            combined_score: Combined score (0-10).
            position_size_pct: Recommended position size as % of portfolio.
            reasoning: Text explanation of signal.
            news_headlines: List of relevant news headlines.
            tags: Optional tags for categorization.

        Returns:
            Signal ID for tracking.
        """
        signal = TrackedSignal(
            symbol=symbol,
            asset_class=asset_class,
            direction=direction,
            signal_type=signal_type,
            conviction=conviction,
            signal_price=signal_price,
            entry_price=entry_price,
            target_price=target_price,
            stop_price=stop_price,
            technical_score=technical_score,
            news_score=news_score,
            combined_score=combined_score,
            position_size_pct=position_size_pct,
            reasoning=reasoning,
            news_headlines=news_headlines or [],
            tags=tags or [],
            status=SignalStatus.PENDING,
            created_at=datetime.now(),
        )

        signal_id = self.store.insert_signal(signal)

        logger.info(
            f"Recorded signal {signal_id}: {direction.value} {symbol} "
            f"@ {entry_price} (conviction: {conviction.value})"
        )

        return signal_id

    def record_from_recommendation(self, recommendation) -> str:
        """
        Record signal from a Recommendation object.

        Args:
            recommendation: Recommendation dataclass from signals module.

        Returns:
            Signal ID for tracking.
        """
        # Map Recommendation fields to TrackedSignal
        # Note: recommendation.current_price -> signal_price
        # recommendation.sentiment_score could map to news_score if news_score is None
        news_score = recommendation.news_score
        if news_score is None and hasattr(recommendation, "sentiment_score"):
            news_score = recommendation.sentiment_score

        return self.record_signal(
            symbol=recommendation.symbol,
            asset_class=recommendation.asset_class,
            direction=SignalDirection(recommendation.direction),
            signal_type=recommendation.signal_type,
            conviction=ConvictionLevel(recommendation.conviction),
            signal_price=recommendation.current_price,
            entry_price=recommendation.entry_price,
            target_price=recommendation.target_price,
            stop_price=recommendation.stop_price,
            technical_score=recommendation.technical_score,
            news_score=news_score,
            combined_score=recommendation.combined_score,
            position_size_pct=recommendation.position_size_pct,
            reasoning=recommendation.reasoning,
            news_headlines=recommendation.news_headlines,
        )

    def mark_delivered(
        self,
        signal_id: str,
        method: str = "email",
        timestamp: Optional[datetime] = None,
    ) -> bool:
        """
        Mark a signal as delivered to user.

        Args:
            signal_id: ID of signal to mark.
            method: Delivery method ("email", "sms", "push").
            timestamp: Delivery timestamp (defaults to now).

        Returns:
            True if successful.
        """
        signal = self.store.get_signal(signal_id)
        if signal is None:
            logger.warning(f"Signal {signal_id} not found for delivery marking")
            return False

        signal.was_delivered = True
        signal.delivery_method = method
        signal.delivered_at = timestamp or datetime.now()

        success = self.store.update_signal(signal)

        if success:
            logger.debug(f"Marked signal {signal_id} as delivered via {method}")

        return success

    def mark_entry_filled(
        self,
        signal_id: str,
        fill_price: Optional[float] = None,
        timestamp: Optional[datetime] = None,
    ) -> bool:
        """
        Mark a signal as having entry filled (position opened).

        Args:
            signal_id: ID of signal.
            fill_price: Actual fill price (for slippage tracking).
            timestamp: Fill timestamp.

        Returns:
            True if successful.
        """
        success = self.store.update_signal_status(
            signal_id=signal_id,
            status=SignalStatus.ACTIVE,
            timestamp=timestamp or datetime.now(),
        )

        if success:
            logger.info(f"Signal {signal_id} entry filled")

        return success

    def mark_expired(
        self,
        signal_id: str,
        timestamp: Optional[datetime] = None,
    ) -> bool:
        """
        Mark a signal as expired (never entered).

        Args:
            signal_id: ID of signal.
            timestamp: Expiration timestamp.

        Returns:
            True if successful.
        """
        return self.store.update_signal_status(
            signal_id=signal_id,
            status=SignalStatus.EXPIRED,
            timestamp=timestamp or datetime.now(),
        )

    def get_pending_signals(self, limit: int = 100) -> List[TrackedSignal]:
        """Get signals waiting for entry."""
        return self.store.get_signals_by_status(SignalStatus.PENDING, limit)

    def get_active_signals(self, limit: int = 100) -> List[TrackedSignal]:
        """Get signals with open positions."""
        return self.store.get_signals_by_status(SignalStatus.ACTIVE, limit)

    def get_recent_signals(
        self,
        days: int = 7,
        symbol: Optional[str] = None,
    ) -> List[TrackedSignal]:
        """Get signals from recent days."""
        return self.store.get_recent_signals(days, symbol)

    def get_signal(self, signal_id: str) -> Optional[TrackedSignal]:
        """Get a specific signal by ID."""
        return self.store.get_signal(signal_id)

    def get_signal_counts(self) -> dict:
        """Get counts of signals by status."""
        return self.store.count_signals_by_status()
